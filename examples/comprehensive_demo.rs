//! Comprehensive demo showcasing all enhanced features
//!
//! This example demonstrates:
//! - Code generation (HTML/CSS/JS)
//! - JS deobfuscation
//! - Continuous learning loop
//! - Online learning integration
//!
//! Run with:
//! ```bash
//! cargo run --example comprehensive_demo
//! ```

use browerai::learning::{
    CodeGenerator, GenerationRequest, CodeType,
    JsDeobfuscator, DeobfuscationStrategy, ObfuscationAnalysis,
    ContinuousLearningLoop, ContinuousLearningConfig,
};
use std::collections::HashMap;

fn main() -> anyhow::Result<()> {
    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .init();

    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘    BrowerAI Comprehensive Enhancement Demo                 â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // ========== Part 1: Code Generation ==========
    println!("\nâ•â•â• Part 1: AI-Powered Code Generation â•â•â•\n");
    demo_code_generation()?;

    // ========== Part 2: JS Deobfuscation ==========
    println!("\nâ•â•â• Part 2: Advanced JS Deobfuscation â•â•â•\n");
    demo_js_deobfuscation()?;

    // ========== Part 3: Continuous Learning ==========
    println!("\nâ•â•â• Part 3: Continuous Learning Loop â•â•â•\n");
    demo_continuous_learning()?;

    println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘                  Demo Completed Successfully                â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    Ok(())
}

/// Demonstrate code generation capabilities
fn demo_code_generation() -> anyhow::Result<()> {
    let generator = CodeGenerator::with_defaults();

    // Generate HTML
    println!("ðŸ”¨ Generating HTML page...");
    let mut html_constraints = HashMap::new();
    html_constraints.insert("title".to_string(), "My Generated Page".to_string());
    html_constraints.insert("heading".to_string(), "Welcome to BrowerAI".to_string());
    html_constraints.insert("content".to_string(), "This page was generated by AI!".to_string());

    let html_request = GenerationRequest {
        code_type: CodeType::Html,
        description: "basic page".to_string(),
        constraints: html_constraints,
    };

    let html_result = generator.generate(&html_request)?;
    println!("âœ… Generated HTML ({} tokens, confidence: {:.2}):",
        html_result.metadata.token_count,
        html_result.confidence
    );
    println!("{}\n", truncate_code(&html_result.code, 200));

    // Generate CSS
    println!("ðŸŽ¨ Generating CSS styles...");
    let mut css_constraints = HashMap::new();
    css_constraints.insert("bg_color".to_string(), "#007bff".to_string());
    css_constraints.insert("text_color".to_string(), "white".to_string());
    css_constraints.insert("padding".to_string(), "12px 24px".to_string());
    css_constraints.insert("radius".to_string(), "8px".to_string());

    let css_request = GenerationRequest {
        code_type: CodeType::Css,
        description: "button style".to_string(),
        constraints: css_constraints,
    };

    let css_result = generator.generate(&css_request)?;
    println!("âœ… Generated CSS ({} tokens, confidence: {:.2}):",
        css_result.metadata.token_count,
        css_result.confidence
    );
    println!("{}\n", truncate_code(&css_result.code, 200));

    // Generate JavaScript
    println!("âš™ï¸  Generating JavaScript function...");
    let mut js_constraints = HashMap::new();
    js_constraints.insert("name".to_string(), "processData".to_string());
    js_constraints.insert("params".to_string(), "data".to_string());
    js_constraints.insert("description".to_string(), "Process and validate data".to_string());
    js_constraints.insert("body".to_string(), "const result = data.map(x => x * 2);".to_string());
    js_constraints.insert("return_value".to_string(), "result".to_string());

    let js_request = GenerationRequest {
        code_type: CodeType::JavaScript,
        description: "function to process data".to_string(),
        constraints: js_constraints,
    };

    let js_result = generator.generate(&js_request)?;
    println!("âœ… Generated JavaScript ({} tokens, confidence: {:.2}):",
        js_result.metadata.token_count,
        js_result.confidence
    );
    println!("{}\n", truncate_code(&js_result.code, 200));

    Ok(())
}

/// Demonstrate JS deobfuscation capabilities
fn demo_js_deobfuscation() -> anyhow::Result<()> {
    let deobfuscator = JsDeobfuscator::new();

    // Test cases with different obfuscation levels
    let test_cases = vec![
        (
            "Minified Code",
            "var a=1;var b=2;var c=a+b;console.log(c);",
        ),
        (
            "Hex Encoding",
            r#"var msg="\x48\x65\x6c\x6c\x6f";console.log(msg);"#,
        ),
        (
            "Complex Obfuscation",
            "function a(b,c){var d=0;for(var e=0;e<b.length;e++){d+=b[e]}return d+c}",
        ),
    ];

    for (name, obfuscated_code) in test_cases {
        println!("ðŸ“Š Analyzing: {}", name);
        
        // Analyze obfuscation
        let analysis = deobfuscator.analyze_obfuscation(obfuscated_code);
        print_analysis(&analysis);

        // Deobfuscate
        println!("ðŸ”§ Deobfuscating...");
        let result = deobfuscator.deobfuscate(obfuscated_code, DeobfuscationStrategy::Comprehensive)?;

        println!("âœ… Deobfuscation completed!");
        println!("   Steps applied: {}", result.steps.len());
        println!("   Readability improvement: {:.2} -> {:.2}",
            result.improvement.readability_before,
            result.improvement.readability_after
        );
        
        println!("   Original: {}", truncate_code(&result.original_code, 80));
        println!("   Result:   {}\n", truncate_code(&result.code, 80));
    }

    Ok(())
}

/// Demonstrate continuous learning loop
fn demo_continuous_learning() -> anyhow::Result<()> {
    println!("ðŸ”„ Starting continuous learning loop (3 iterations)...\n");

    let mut config = ContinuousLearningConfig::default();
    config.max_iterations = Some(3);
    config.update_interval_secs = 0; // No delay for demo
    config.auto_generate = true;

    let mut learning_loop = ContinuousLearningLoop::new(config);

    // Run 3 iterations manually to show progress
    for i in 1..=3 {
        println!("ðŸ“ Iteration {}/3", i);
        
        let events = learning_loop.run_iteration()?;
        
        println!("   Events: {}", events.len());
        for event in events {
            match event {
                browerai::learning::continuous_loop::LearningEvent::SampleCollected(_) => {
                    print!(".");
                }
                browerai::learning::continuous_loop::LearningEvent::ModelUpdated(count) => {
                    println!("\n   âœ… Model updated (update #{})", count);
                }
                browerai::learning::continuous_loop::LearningEvent::CodeGenerated(code_type) => {
                    println!("   ðŸ”¨ Generated {:?} code", code_type);
                }
                browerai::learning::continuous_loop::LearningEvent::IterationCompleted(iter, duration) => {
                    println!("\n   â±ï¸  Iteration {} completed in {:.2}ms", iter, duration.as_secs_f64() * 1000.0);
                }
                _ => {}
            }
        }
        println!();
    }

    // Show final statistics
    let stats = learning_loop.get_stats();
    println!("\nðŸ“Š Learning Loop Statistics:");
    println!("   Total iterations: {}", stats.iterations);
    println!("   Samples processed: {}", stats.samples_processed);
    println!("   Model updates: {}", stats.updates_performed);
    println!("   Codes generated: {}", stats.codes_generated);
    println!("   Avg iteration time: {:.2}ms", stats.avg_iteration_time_ms);
    println!("   Success rate: {:.2}%", stats.success_rate * 100.0);

    let learner_stats = learning_loop.get_learner_stats();
    println!("\nðŸ“ˆ Online Learner Statistics:");
    println!("   Total samples: {}", learner_stats.total_samples);
    println!("   Buffered samples: {}", learner_stats.buffered_samples);
    println!("   Learning rate: {}", learner_stats.learning_rate);

    Ok(())
}

/// Print obfuscation analysis
fn print_analysis(analysis: &ObfuscationAnalysis) {
    println!("   Obfuscation Score: {:.2}/1.0", analysis.obfuscation_score);
    println!("   Techniques Detected: {}", analysis.techniques.len());
    
    for technique in &analysis.techniques {
        println!("      - {:?}", technique);
    }
    
    println!("   Complexity Metrics:");
    println!("      Variables: {}", analysis.complexity.variable_count);
    println!("      Functions: {}", analysis.complexity.function_count);
    println!("      Max Nesting: {}", analysis.complexity.max_nesting_depth);
    println!("      Avg Var Name Length: {:.1}", analysis.complexity.avg_var_name_length);
    
    if !analysis.suggestions.is_empty() {
        println!("   Suggestions:");
        for suggestion in &analysis.suggestions {
            println!("      â€¢ {}", suggestion);
        }
    }
    println!();
}

/// Truncate code for display
fn truncate_code(code: &str, max_len: usize) -> String {
    if code.len() <= max_len {
        code.to_string()
    } else {
        format!("{}... [truncated]", &code[..max_len])
    }
}
